<body>
<!--
!!html_title Basic ray tracing demo - Computer Graphics from scratch
-->
<canvas id="canvas" width=600 height=600 style="border: 1px grey solid"></canvas>

<script>

  // ======================================================================
  //  Low-level canvas access.
  // ======================================================================

  var canvas = document.getElementById("canvas");
  var canvas_context = canvas.getContext("2d");
  var canvas_buffer = canvas_context.getImageData(0, 0, canvas.width, canvas.height);
  /**
   * canvas_pitch è¡¨ç¤º canvas_buffer ä¸­æ¯ä¸€è¡Œåƒç´ æ‰€å çš„å­—èŠ‚æ•°ã€‚
   * è¿™é‡Œå°†ç¼“å†²åŒºå®½åº¦ä¹˜ä»¥4,æ˜¯å› ä¸ºå¯¹äºä¸€ä¸ªåƒç´ ,
   * ImageData å¯¹è±¡ä½¿ç”¨4ä¸ªå€¼æ¥è¡¨ç¤º:çº¢è‰²ã€ç»¿è‰²ã€è“è‰²å’Œé€æ˜åº¦,æ¯ä¸ªå€¼å 1ä¸ªå­—èŠ‚ã€‚
   * è®¡ç®— canvas_pitch æ˜¯ä¸ºäº†åç»­æ–¹ä¾¿é€šè¿‡åç§»é‡æ¥è®¿é—® canvas_buffer ä¸­çš„åƒç´ æ•°æ®ã€‚
   * @type {number}
   */
  var canvas_pitch = canvas_buffer.width * 4;


  // å°†æŒ‡å®šåæ ‡å­˜å…¥ buffer é‡Œé¢
  var PutPixel = function (x, y, color) {
    // x = 600 / 2 + x è¿™ä¸€æ­¥æ˜¯æŠŠ x å®šä½åˆ°ä»¥ canvas ä¸­å¿ƒä¸ºåŸç‚¹çš„ä½ç½®

    x = (canvas.width / 2) + x;
    y = (canvas.height / 2) - y - 1;

    /**
     *       -300,-300                300,0
     *           _______________________
     *           |                     |
     *           |                     |
     *           |                     |
     *           |                     |
     *           |         Ori         |
     *           |                     |
     *           |                     |
     *           |                     |
     *           |                     |
     *           _______________________
     *      -300,300                 -300, 300
     *
     */
    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
      return;
    }

    var offset = 4 * x + canvas_pitch * y;
    canvas_buffer.data[offset++] = color[0];
    canvas_buffer.data[offset++] = color[1];
    canvas_buffer.data[offset++] = color[2];
    canvas_buffer.data[offset++] = 255; // Alpha = 255 (full opacity)
  }


  // Displays the contents of the offscreen buffer into the canvas.
  var UpdateCanvas = function () {
    canvas_context.putImageData(canvas_buffer, 0, 0);
  }


  // ======================================================================
  //  Linear algebra and helpers.
  // ======================================================================

  // Dot product of two 3D vectors.
  var DotProduct = function (v1, v2) {
    return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
  }


  /**
   *
   * @param v1
   * @param v2
   * @returns {[number, number, number]}
   * @constructor
   */
  var Subtract = function (v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
  }


  // ======================================================================
  //  A very basic raytracer.
  // ======================================================================

  // A Sphere.
  var Sphere = function (center, radius, color) {
    this.center = center;
    this.radius = radius;
    this.color = color;
  }

  // Scene setup.
  var viewport_size = 1;
  var projection_plane_z = 1;
  var camera_position = [0, 0, 0];
  var background_color = [255, 255, 255];
  var spheres = [
    new Sphere([0, -1, 3], 1, [255, 0, 0]),
    new Sphere([2, 0, 4], 1, [0, 0, 255]),
    new Sphere([-2, 0, 4], 1, [0, 255, 0])
  ];


  // 2d åæ ‡è½¬æ¢ä¸ºè§†å›¾åæ ‡
  var CanvasToViewport = function (p2d) {
    return [p2d[0] * viewport_size / canvas.width,
      p2d[1] * viewport_size / canvas.height,
      projection_plane_z];
  }


  /**
   * å…‰çº¿çš„å‚æ•°æ–¹ç¨‹
   * å…‰çº¿çš„å‚æ•°æ–¹ç¨‹æè¿°äº†å…‰çº¿ä¸Šæ¯ä¸€ç‚¹çš„åæ ‡, å¯ä»¥å†™æˆ ğ‘ƒ (ğ‘¡) = ğ‘‚ + ğ‘¡ğ·
   * P(t) è¡¨ç¤ºå…‰çº¿ä¸Šå‚æ•°ä¸º t çš„ç‚¹çš„åæ ‡
   * t: æœ D æ–¹å‘ç§»åŠ¨çš„è·ç¦»
   * O: å…‰çº¿èµ·ç‚¹
   * D: å…‰çº¿æ–¹å‘(å½’ä¸€åŒ–)
   * å…‰çº¿å‚æ•°æ–¹ç¨‹åæ˜ äº†å…‰çº¿çš„å‡ ä½•æ€§è´¨,å³å®ƒæ˜¯ä¸€æ¡æ— é™é•¿çš„ç›´çº¿,èµ·ç‚¹ä¸º ğ‘‚,æ–¹å‘ä¸º ğ·ã€‚é€šè¿‡æ”¹å˜å‚æ•° ğ‘¡ çš„å€¼,æˆ‘ä»¬å¯ä»¥å¾—åˆ°å…‰çº¿ä¸Šä»»æ„ä¸€ç‚¹çš„åæ ‡ã€‚
   * ---------------------
   * çƒé¢æ–¹ç¨‹
   * çƒé¢æ–¹ç¨‹æè¿°äº†åˆ°çƒå¿ƒè·ç¦»ç­‰äºåŠå¾„çš„æ‰€æœ‰ç‚¹çš„é›†åˆã€‚å¯¹äºçƒå¿ƒåœ¨ (cx, cy, cz) çš„çƒä½“,å®ƒçš„æ–¹ç¨‹å¯ä»¥å†™æˆ:
   * (xâˆ’cx)Â²+(yâˆ’cy)Â²+(zâˆ’cz)Â²=rÂ²
   * xyz è¡¨ç¤ºçƒé¢(æŠŠçƒæƒ³è±¡æˆä¸‰ç»´çš„, è¿™é‡Œçš„ xyz ä»…ä»…æ˜¯çƒé¢çš„åæ ‡) ä»»æ„ä¸€ç‚¹çš„åæ ‡, åªè¦æ»¡è¶³ä¸Šé¢çš„å…¬å¼, å°±è¡¨ç¤ºè¿™ä¸ªç‚¹æ˜¯çƒé¢
   * è‹¥çƒçš„ä¸­å¿ƒç‚¹æ°å¥½ä¸ºåŸç‚¹(0,0,0)åˆ™æ–¹ç¨‹å¯ä»¥ç®€åŒ–ä¸º xÂ²+yÂ²+zÂ²=rÂ²
   * ----------------------
   * 1. åœ¨ä¸‰ç»´ç©ºé—´ä¸­åˆ°çƒå¿ƒ C çš„è·ç¦»ç­‰äº r çš„ç‚¹ P é›†åˆæ„æˆä¸€ä¸ªçƒé¢
   * 2. è®¡ç®—ä¸¤ä¸ªå‘é‡è·ç¦» d = |V1 - V2| = å¼€å¹³æ–¹( (V1.x - V2.x)Â² + (V1.y - V2.y)Â² + (V1.z - V2.z)Â² )
   * 3. çƒé¢ä»»æ„ç‚¹åˆ°çƒå¿ƒçš„è·ç¦», P ä¸ºä»»æ„ç‚¹, C ä¸ºçƒå¿ƒ
   *  3.1 P åˆ° C çš„è·ç¦» = |P - C| = å¼€å¹³æ–¹( (P.x - C.x)Â² + (P.y - C.y)Â² + (P.z - C.z)Â² )
   * 4. æ ¹æ®çƒä½“å®šä¹‰, çƒé¢ä»»æ„ä¸€ç‚¹åˆ°çƒå¿ƒçš„è·ç¦»ç­‰äºåŠå¾„ r
   *  4.1 r = å¼€å¹³æ–¹( (P.x - C.x)Â² + (P.y - C.y)Â² + (P.z - C.z)Â² )
   *  4.2 å‰Šå»å¼€å¹³æ–¹ rÂ² = (P.x - C.x)Â² + (P.y - C.y)Â² + (P.z - C.z)Â²
   *  4.3 åˆå·²çŸ¥ |P - C| = r
   *  4.4 å¯ä»¥å¾—åˆ° (P - C) Â· (P - C) = rÂ²
   *
   * å°†å…‰çº¿æ–¹ç¨‹å¸¦å…¥çƒé¢
   *
   *
   * åˆ¤æ–­ä¸€ä¸ªå°„çº¿æ˜¯å¦ä¸çƒä½“ç›¸äº¤
   * @param origin - å…‰çº¿çš„å‡ºå‘ç‚¹(ç°åœ¨æ˜¯ç›¸æœºä½ç½®)
   * @param direction - å…‰çº¿çš„æ–¹å‘,ä¸€ä¸ªå•ä½é•¿åº¦çš„ä¸‰ç»´å‘é‡
   * @param sphere - ä¸€ä¸ª Sphere å¯¹è±¡,åŒ…å«çƒå¿ƒåæ ‡å’ŒåŠå¾„ç­‰å±æ€§
   * @returns {[number,number]}
   * @constructor
   */
  var IntersectRaySphere = function (origin, direction, sphere) {
    // è®¡ç®—å…‰çº¿è‡³çƒä½“çš„ä¸­å¿ƒçš„è·ç¦»
    var oc = Subtract(origin, sphere.center);

    /**
     * å…‰çº¿ä¸çƒä½“çš„ç›¸äº¤é—®é¢˜å¯ä»¥è½¬åŒ–ä¸ºæ±‚è§£ä¸€ä¸ªä¸€å…ƒäºŒæ¬¡æ–¹ç¨‹ã€‚è¿™ä¸ªä¸€å…ƒäºŒæ¬¡æ–¹ç¨‹çš„å½¢å¼å¦‚ä¸‹
     * k1 * t^2 + k2 * t + k3 = 0
     *
     *
     */
    var k1 = DotProduct(direction, direction);
    var k2 = 2 * DotProduct(oc, direction);
    var k3 = DotProduct(oc, oc) - sphere.radius * sphere.radius;

    var discriminant = k2 * k2 - 4 * k1 * k3;
    if (discriminant < 0) {
      return [Infinity, Infinity];
    }

    var t1 = (-k2 + Math.sqrt(discriminant)) / (2 * k1);
    var t2 = (-k2 - Math.sqrt(discriminant)) / (2 * k1);
    return [t1, t2];
  }


  /**
   * å…‰çº¿è¿½è¸ª
   * @param origin - å…‰çº¿çš„å‡ºå‘ç‚¹(ç°åœ¨æ˜¯ç›¸æœºä½ç½®)
   * @param direction - å…‰çº¿çš„æ–¹å‘,ä¸€ä¸ªå•ä½é•¿åº¦çš„ä¸‰ç»´å‘é‡
   * @param min_t - å…‰çº¿è¿½è¸ªçš„æœ€å°è·ç¦»é™åˆ¶ï¼Œç”¨äºå‰ªè£æ‰è¿‡è¿‘çš„äº¤ç‚¹ã€‚
   * @param max_t - å…‰çº¿è¿½è¸ªçš„æœ€å¤§è·ç¦»é™åˆ¶ï¼Œç”¨äºå‰ªè£æ‰è¿‡è¿œçš„äº¤ç‚¹ã€‚
   * @returns {number[]|*}
   * @constructor
   */
  var TraceRay = function (origin, direction, min_t, max_t) {
    // åˆå§‹åŒ–ä¸ºInfinityï¼Œç”¨æ¥è®°å½•å…‰çº¿ä¸çƒä½“äº¤ç‚¹ä¸­æœ€è¿‘çš„é‚£ä¸ªäº¤ç‚¹çš„è·ç¦»ã€‚
    var closest_t = Infinity;
    // closest_sphere: åˆå§‹åŒ–ä¸ºnullï¼Œç”¨æ¥è®°å½•ä¸å…‰çº¿ç›¸äº¤çš„æœ€è¿‘çš„çƒä½“ã€‚
    var closest_sphere = null;

    for (var i = 0; i < spheres.length; i++) {
      // åˆ¤æ–­æ˜¯å¦ä¸çƒç›¸äº¤
      var ts = IntersectRaySphere(origin, direction, spheres[i]);
      if (ts[0] < closest_t && min_t < ts[0] && ts[0] < max_t) {
        closest_t = ts[0];
        closest_sphere = spheres[i];
      }
      if (ts[1] < closest_t && min_t < ts[1] && ts[1] < max_t) {
        closest_t = ts[1];
        closest_sphere = spheres[i];
      }
    }

    if (closest_sphere == null) {
      return background_color;
    }

    return closest_sphere.color;
  }


  for (var x = -canvas.width / 2; x < canvas.width / 2; x++) {
    for (var y = -canvas.height / 2; y < canvas.height / 2; y++) {
      // è½¬æ¢ä¸º 3d çš„åæ ‡
      var direction = CanvasToViewport([x, y])
      var color = TraceRay(camera_position, direction, 1, Infinity);
      PutPixel(x, y, color);
    }
  }

  UpdateCanvas();


</script>

</body>
