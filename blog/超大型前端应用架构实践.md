# 大型前端应用实践



> 大家好，我是一个有将近四年经验的前端开发，做过不少 React Native，Uni APP，React，Vue 项目，也做过复杂的基于 Canvas 的 Web 交互应用，花费精力最多的是 SaaS 平台，做过 ToB 的朋友应该都知道，ToB 项目相较于 ToC 项目复杂度只能说有过之无不及，并且对于稳定性和性能要求都很高，唯一的好处就是可以使用一些相对先进的技术，这篇文章我将会讲一讲我在实际项目中所使用的的架构，以及如何使用架构应对复杂问题。



## 核心理念

- 提升视图层状态。
- 关注点分离。

### 什么是提升视图层状态？

在线我们开发前端应用往往要依赖于前端框架( `Angular`, `React`, `Vue `)，而这些框架的视图层的状态必须要和框架绑定，例如在 `React(Hooks)` 中，我们获取一个问题 (Issue) 时状态需要声明两个对象，`issue 和 loading` 。

```react
const IssueDisplayer = () => {
    // 问题对象
    const [issue, updateIssue] = useState<null | Issue>(null)
    const [loading, setLoading] = useState(false)
    const getIssue = () => {
        setLoading(true)
        
        http.request({
            url: "/issues/issueId"
        })
        .then(res => {
            updateIssue(res)
        })
        .finally(() => {
            setLoading(false)
        })
    }
    
    useEffect(() => {
        getIssue()
    }, [])
    
    return <div> .... </div>
}


```

现在我们有一个问题，我需要在微信小程序中也进行获取问题的操作，那么是不是也要写类似的代码在微信小程序中？这样一来我们就需要在两个端编写相同功能，但是代码不同，这是一件非常糟糕的事情，假设我们有了一个新的业务场景，我们需要在获取问题后获取问题关联的一些附件，那么代码大概要变成这样：

```react
const IssueDisplayer = () => {
    // 问题对象
    const [issue, updateIssue] = useState<null | Issue>(null)
    const [getIssueLoading, setGetIssueLoading] = useState(false)
    // 问题附件
    const [issueAttachments, updateIssueAttachments] = useState<null | IssueAttchment[]>([])
    const [getIssueAttachmentsLoading, setGetIssueAttachmentsLoading] = useState(false)
    
    const getIssue = () => {
        setGetIssueLoading(true)
        
        http.request({
            url: "/issues/issueId"
        })
        .then(res => {
            updateIssue(res)
        })
        .finally(() => {
            setGetIssueLoading(false)
        })
    }
    
    const getIssueAttachments = () => {
        setGetIssueAttachmentsLoading(true)
        
        http.request({
            url: "/issues/issueId/attachments"
        })
        .then(res => {
            updateIssueAttachments(res)
        })
        .finally(() => {
            setGetIssueAttachmentsLoading(false)
        })
    }
    
    useEffect(() => {
        getIssue()
        getIssueAttachments()
    }, [])
    
    return <div> .... </div>
}
```

是否意识到了问题，同样的代码如果仅仅是获取问题，我们可能还能勉强接受在多个端重复编写，但是获取问题同时，获取附件这些动作多了之后，如果每个端状态都要重新声明，那么将是非常糟糕的开发体验（笔者就有幸体验很长时间），



## 常见问题

### 我应该使用 Typescript 吗？

必须。

### 是不是只要把我的项目改造成你的项目结构就OK了？

当然不对，架构并非文件结构，准确说更像是一种思想，而构建这种思想你需要的不仅仅是组织代码的方式，你还需要`基础设施开发/选型`，`规范/约束`等等。

### 我应该使用依赖注入还是手动实例化？

使用依赖注入可以极大的减少代码，在本架构的示例中是作为一个不可缺少的部分，但是你仍然可以在自己的项目中将他去掉，这并不会影响整个架构的设计，但是这会让你在开发中增加心智负担。

### DTO 是必须的吗？

并不是，这取决于项目中前端与后端的配合，DTO 更像大前端中提到的 `BFF` 层的一部分。

例如在笔者的项目开发中日期都是使用 `ISO 8601` 规范的传递的，显然这种格式对于用户不够友好，所以显示之前都要先格式化一下。

例如笔者的项目中大量的使用了枚举字面量，例如问题状态为 `pendding`(等待中)，如果 `UI` 需要展示状态肯定不能直接展示 `pendding` 而是展示 `等待中`，这个格式化动作笔者就放在了 DTO 对象中。

但是这真的适用于你的项目吗？这是一个值得思考的问题，你可以为 "将来" 设计，即使不需要也先加上，也可以直接省略 DTO，但是无论如何最后的结果还是要你自己来承担。





## 常见约束

- 业务模块代码必须是懒加载，避免影响主包体积
- 业务模块代码不应该互相依赖
- 框架应该能够提供支持复杂数据的校验流程，该验证函数应该是独立的，不依附于某个 UseCase
- 框架应该隔离实体(Entity)和 DTO 的关系
- 框架应该提供一些基类与基础接口，方便开发者快速理解组件之间的关系
- uniapp 应该显式设置 useDefineForClassFields 在 tsconfig.json 
- 优先使用命名空间和默认导出，不然在大型项目



## 基座 (Hosting)

基座为特定端提供运行环境和基础设施，例如 `Vue` 的基座，应该提供可以在 `Vue` 环境中运行的 `HttpClient`, `AuthenticationService`，在本项目中，我使用依赖注入来提供。



## 准备好了吗？

这套架构是根据 [clean architecture]([Clean Coder Blog](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)) 的思想设计的，但是原有的部分思想对于笔者面对的实际场景有些不合适的地方，所以本文也并非完全按照 clean architecture 的思路设计，笔者在使用现有的架构之前，还尝试过别的方向，最终花了很长时间才稳定下来，所以即使你阅读完了本文也仍然需要经过大量的摸索才能实现你理想中的架构，下面是笔者在探索的过程中所阅读的文章。





## 清洁架构理论

